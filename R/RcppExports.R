# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title findNumberInVector
#' @description Function that finds number in vector and return indices
#' @param number integer to search for
#' @param vec Integervector that is searched in 
#' @return indices of number in vector (0=1st entry of vector) 
#' @export
findNumberInVector <- function(number, vec) {
    .Call('_WaterGAPLite_findNumberInVector', PACKAGE = 'WaterGAPLite', number, vec)
}

#' @title findUniqueValues
#' @description Function that returns values in vector without duplicates
#' @param vec Integervector that is examined
#' @return Vector with values in vector without duplicates
#' @export
findUniqueValues <- function(vec) {
    .Call('_WaterGAPLite_findUniqueValues', PACKAGE = 'WaterGAPLite', vec)
}

#' @title sortIt
#' @description Function that sort a vector in ascending order (or descending not sure about that)
#' @param vec Integervector that is examined
#' @return sorted vector
#' @export
sortIt <- function(vec) {
    .Call('_WaterGAPLite_sortIt', PACKAGE = 'WaterGAPLite', vec)
}

#' @title sumVector
#' @description Function that sums up a vector
#' @param vec Numericvector that is sumed up
#' @return sum of vector as double
#' @export
sumVector <- function(vec) {
    .Call('_WaterGAPLite_sumVector', PACKAGE = 'WaterGAPLite', vec)
}

#' @title numberOfDaysInMonth
#' @description Function that gives the number of Days in month
#' @param month as integer (1 = january)
#' @param year as integer 
#' @return number of days of specified month in specified year as integer
numberOfDaysInMonth <- function(month, year) {
    .Call('_WaterGAPLite_numberOfDaysInMonth', PACKAGE = 'WaterGAPLite', month, year)
}

#' @title numberOfDaysInYear
#' @description Function that gives the number of Days in year
#' @param year as integer 
#' @return number of days of specified year as integer
numberOfDaysInYear <- function(year) {
    .Call('_WaterGAPLite_numberOfDaysInYear', PACKAGE = 'WaterGAPLite', year)
}

#' @title WaterUseConsumGW
#' @description function that abstracts water use from groundwater storage 
#' @param cell cell in basin that is used for abstraction
#' @param GroundwaterStorage groundwater storage level (can be negative due to abstraction)
#' @param dailyUse information of water that needs to be abstracted from groundwater (first row of NumericMatrix)
#' @return GWdailyuse abstracted groundwater (if there is no landfraction in cell, no water can be abstracted from groundwater)
#' @export
WaterUseConsumGW <- function(cell, GroundwaterStorage, dailyUse) {
    .Call('_WaterGAPLite_WaterUseConsumGW', PACKAGE = 'WaterGAPLite', cell, GroundwaterStorage, dailyUse)
}

#' @title WaterUseCalcMeanDemandDaily
#' @description Prepare infromation for reservoir (calculate yearly mean demand of cell itself and next 20 downstream cells)
#' @param year year of simulation period as integer
#' @param GapYearType Info from Setting wheter 29.02 is simulated (0) or not (1)
#' @return G_mean_demand as numericVector for the sepcified year in [mm*km²/day]
#' @export
WaterUseCalcMeanDemandDaily <- function(year, GapYearType) {
    .Call('_WaterGAPLite_WaterUseCalcMeanDemandDaily', PACKAGE = 'WaterGAPLite', year, GapYearType)
}

#' @title WaterUseCalcDaily
#' @description calculates daily water use for groundwater and surface water (note that GapYearType needs to be included in function input)
#' @param waterUseType 0 (no water use), 1 (only water use without Transport to cities) or 2 (only water use with Transport to cities)
#' @param dailyUse Matrix with two rows that gives water use for actual day in mm*km²/day (first = GW, second=SW+TF), note that all days in one month in one year have same values
#' @param year year of simulation period as integer
#' @param month month of simulation period as integer
#' @param StartYear information to get the right column from read water use information
#' @param Info_GW read water use information from groundwater
#' @param Info_SW read water use information from surface water
#' @param Info_TF read water use information for transport to cities
#' @export
WaterUseCalcDaily <- function(waterUseType, dailyUse, year, month, StartYear, Info_GW, Info_SW, Info_TF) {
    invisible(.Call('_WaterGAPLite_WaterUseCalcDaily', PACKAGE = 'WaterGAPLite', waterUseType, dailyUse, year, month, StartYear, Info_GW, Info_SW, Info_TF))
}

#' @title Calculating waterbalance of basin
#' @description {
#' daily routine for each cell
#' this routine is already validated against WG3 simulation for a small basin in South America
#' especially the snow routine and immediate RunOff generation are NOT validated therefore 
#' have to check the simulation results also for other basins to assure a good match with WG3
#' e.g. for european basins with snow processes and sealed areas! (Bayern?) }
#' @param timestring Datevector with dates of simulation period
#' @return List Vwith daily water balance for whole simulaiton period as output
#' @export
createWaterBalance <- function(timestring) {
    .Call('_WaterGAPLite_createWaterBalance', PACKAGE = 'WaterGAPLite', timestring)
}

#' @title Calculate longwave radiation
#' @description estimation of longwave radiation when it is not given as measured variable
#' @param n index of specific cell
#' @param DOY day of the year (between 1 and 365)
#' @param dailyTempC Temperature of Day in Degree
#' @param dailyShortWave shortwave radiation as double in W/m²
#' @return net_long_wave_rad net longwave radiation in W/m²
#' @export
dailyEstimateLongwave <- function(n, DOY, dailyTempC, dailyShortWave) {
    .Call('_WaterGAPLite_dailyEstimateLongwave', PACKAGE = 'WaterGAPLite', n, DOY, dailyTempC, dailyShortWave)
}

#' @title Calculate shortwave radiation
#' @description rcpp function to estimate Shortwave radiation when not given as measured input
#' @param SimDates Datevector of Simulation period
#' @param TempC Temperatur as NumericMatrix in degree
#' @param Sunshine Sunshine duration as NumericMatrix  in hours
#' @param GR information of row for cells
#' @param cor_row information of correction of rows for continental grid
#' @return ShortwaveDownMatrix Matrix with estimated shortwave radiation in W/m²
#' @export
dailyEstimateShortwave <- function(SimDates, TempC, Sunshine, GR, cor_row) {
    .Call('_WaterGAPLite_dailyEstimateShortwave', PACKAGE = 'WaterGAPLite', SimDates, TempC, Sunshine, GR, cor_row)
}

#' @title snow storage interpolation
#' @description snow storage is calculated in sub-grid scale (1min) and aggregated to 5min after each day/iteration
#' @param day day of simulation period as integer
#' @param daily_prec_to_soil throughfall from canopy
#' @param G_snow snow storage at 5min scale
#' @param G_snowWaterEquivalent amount of water in snow storage at sub-grid scale
#' @param dailySnowMelt snow melt on 5min cell
#' @param dailySnowEvapo sublimation of snow on 5min cell
#' @param thresh_elev helper - information of reference height,when there is unlimited snow accummulation (> 1000mm)
#' @param dailyEffPrec effective precipitation to soil (throughfall + snow melt - fallen snow)
#' @param dailySoilPET energy for PET which is left for soil
#' @export
dailySnow <- function(day, daily_prec_to_soil, G_snow, G_snowWaterEquivalent, dailySnowMelt, dailySnowEvapo, thresh_elev, dailyEffPrec, dailySoilPET) {
    invisible(.Call('_WaterGAPLite_dailySnow', PACKAGE = 'WaterGAPLite', day, daily_prec_to_soil, G_snow, G_snowWaterEquivalent, dailySnowMelt, dailySnowEvapo, thresh_elev, dailyEffPrec, dailySoilPET))
}

#' @title routing
#' @description this function includes als routing modules
#' @param SimPeriod Datevector of Simulationperiod
#' @param surfaceRunoff run-off from surface contributing to river network
#' @param GroundwaterRunoff run-off from groundwater contributing to river network
#' @param PETw Potential Evapotranspiration as NumericMatrix in mm/d (to calculate water balance of waterbodies)
#' @param Prec Precipitation as NumericMatrix in mm/d
#' @export
routing <- function(SimPeriod, surfaceRunoff, GroundwaterRunoff, PETw, Prec) {
    .Call('_WaterGAPLite_routing', PACKAGE = 'WaterGAPLite', SimPeriod, surfaceRunoff, GroundwaterRunoff, PETw, Prec)
}

#' @title CheckResType
#' @description function to simulate reservoirs as global lakes, when res_type is zero, so unknown
#' @export
CheckResType <- function() {
    invisible(.Call('_WaterGAPLite_CheckResType', PACKAGE = 'WaterGAPLite'))
}

#' @title setLakeWetlandToMaximum
#' @description function that sets storage of all surface water bodies to max; is implemented in original model version (actually because of this, warm-up-period should be quite long > 2a)
#' @param S_locLakeStorage local lake storage 
#' @param S_locWetlandStorage local wetland storage
#' @param S_gloLakeStorage global lake storage 
#' @param S_ResStorage reservoir storage
#' @param S_gloWetlandStorage global wetland storage
#' @export
setLakeWetlandToMaximum <- function(S_locLakeStorage, S_locWetlandStorage, S_gloLakeStorage, S_ResStorage, S_gloWetlandStorage) {
    invisible(.Call('_WaterGAPLite_setLakeWetlandToMaximum', PACKAGE = 'WaterGAPLite', S_locLakeStorage, S_locWetlandStorage, S_gloLakeStorage, S_ResStorage, S_gloWetlandStorage))
}

#' @title routingRiver
#' @description function that defines routing through river - note: uses original model code with bug in ELS equation
#' @param cell cell that is simulated 
#' @param riverVelocity river velocity in km/d
#' @param RiverInflow inflow to river network [mm*km²/d]
#' @param G_riverOutflow transportedVolume in [mm*km²/d]
#' @param S_river river storage [mm*km²]
#' @return transportedVolume in [mm*km²/d]
#' @export
routingRiver <- function(cell, riverVelocity, RiverInflow, G_riverOutflow, S_river) {
    .Call('_WaterGAPLite_routingRiver', PACKAGE = 'WaterGAPLite', cell, riverVelocity, RiverInflow, G_riverOutflow, S_river)
}

#' @title getRiverVelocity
#' @description function that defines river velocity for routing (variable or constant)
#' @param Type 0 (constant) or 1 (variable)
#' @param cell cell that is simulated
#' @param inflow inflow to river in mm*km²/day 
#' @return riverVelocity in km/day
#' @export
getRiverVelocity <- function(Type, cell, inflow) {
    .Call('_WaterGAPLite_getRiverVelocity', PACKAGE = 'WaterGAPLite', Type, cell, inflow)
}

#' @title runModel
#' @description run whole model including model initializing, warm-up period, water balance and routing and returns list with states and fluxes 
#' @param SimPeriod Period to simulate (usually defines as model[["SimPeriod"]] where model is object returned from basin.prepareRun())
#' @param ListConst list with all required information regarding basin and input (usually, object returned by basin.prepareRun())
#' @param Settings vector that is used to define settings
#' @param nYears number of years defined as warm-up (first year is then simulated n times, before starting with the actual simulation)
#' @export
runModel <- function(SimPeriod, ListConst, Settings, nYears) {
    .Call('_WaterGAPLite_runModel', PACKAGE = 'WaterGAPLite', SimPeriod, ListConst, Settings, nYears)
}

#' @title tools_DefDrainageCells
#' @description rcpp tool to define Drainage Cells 
#' @param Outlet of basin as GCRC number in continental grid
#' @param GCRC as vector for continent
#' @param OutflowMatrix as vector for continent 
#' @return IntegerVector with GCRC-IDs that are part of basin
#' @export
tools_DefDrainageCells <- function(Outlet, GCRC, OutflowMatrix) {
    .Call('_WaterGAPLite_tools_DefDrainageCells', PACKAGE = 'WaterGAPLite', Outlet, GCRC, OutflowMatrix)
}

#' @title tools_InterpolateValues
#' @description rcpp function for interpolation of a vector (alternative could be using r function and apply)
#' @param VectorIn vector as base for interpolation
#' @param Table_x Table_x of values 
#' @param Table_y Table_y of values 
#' @return NumericVector with interpolated output
#' @export
tools_InterpolateValues <- function(VectorIn, Table_x, Table_y) {
    .Call('_WaterGAPLite_tools_InterpolateValues', PACKAGE = 'WaterGAPLite', VectorIn, Table_x, Table_y)
}

