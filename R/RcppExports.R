# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title findNumberInVector
#' @description Function that finds number in vector and return indices
#' @param number integer to search for
#' @param vec Integervector that is searched in 
#' @return indices of number in vector (0=1st entry of vector) 
#' @export
findNumberInVector <- function(number, vec) {
    .Call(`_WaterGAPLite_findNumberInVector`, number, vec)
}

#' @title findUniqueValues
#' @description Function that returns values in vector without duplicates
#' @param vec Integervector that is examined
#' @return Vector with values in vector without duplicates
#' @export
findUniqueValues <- function(vec) {
    .Call(`_WaterGAPLite_findUniqueValues`, vec)
}

#' @title sortIt
#' @description Function that sort a vector in ascending order (or descending not sure about that)
#' @param vec Integervector that is examined
#' @return sorted vector
#' @export
sortIt <- function(vec) {
    .Call(`_WaterGAPLite_sortIt`, vec)
}

#' @title sumVector
#' @description Function that sums up a vector
#' @param vec Numericvector that is sumed up
#' @return sum of vector as double
#' @export
sumVector <- function(vec) {
    .Call(`_WaterGAPLite_sumVector`, vec)
}

#' @title numberOfDaysInMonth
#' @description Function that gives the number of Days in month
#' @param month as integer (1 = january)
#' @param year as integer 
#' @return number of days of specified month in specified year as integer
numberOfDaysInMonth <- function(month, year) {
    .Call(`_WaterGAPLite_numberOfDaysInMonth`, month, year)
}

#' @title numberOfDaysInYear
#' @description Function that gives the number of Days in year
#' @param year as integer 
#' @return number of days of specified year as integer
numberOfDaysInYear <- function(year) {
    .Call(`_WaterGAPLite_numberOfDaysInYear`, year)
}

#' @title WaterUseConsumGW
#' @description function that abstracts water use from groundwater storage 
#' @param cell cell in basin that is used for abstraction
#' @param GroundwaterStorage groundwater storage level (can be negative due to abstraction)
#' @param dailyUse information of water that needs to be abstracted from groundwater (first row of NumericMatrix)
#' @return GWdailyuse abstracted groundwater (if there is no landfraction in cell, no water can be abstracted from groundwater)
#' @export
WaterUseConsumGW <- function(cell, GroundwaterStorage, dailyUse) {
    .Call(`_WaterGAPLite_WaterUseConsumGW`, cell, GroundwaterStorage, dailyUse)
}

#' @title WaterUseCalcMeanDemandDaily
#' @description Prepare infromation for reservoir (calculate yearly mean demand of cell itself and next 20 downstream cells)
#' @param year year of simulation period as integer
#' @param GapYearType Info from Setting wheter 29.02 is simulated (0) or not (1)
#' @return G_mean_demand as numericVector for the sepcified year in [mm*km²/day]
#' @export
WaterUseCalcMeanDemandDaily <- function(year, GapYearType) {
    .Call(`_WaterGAPLite_WaterUseCalcMeanDemandDaily`, year, GapYearType)
}

#' @title WaterUseCalcDaily
#' @description calculates daily water use for groundwater and surface water (note that GapYearType needs to be included in function input)
#' @param waterUseType 0 (no water use), 1 (only water use without Transport to cities) or 2 (only water use with Transport to cities)
#' @param dailyUse Matrix with two rows that gives water use for actual day in mm*km²/day (first = GW, second=SW+TF), note that all days in one month in one year have same values
#' @param year year of simulation period as integer
#' @param month month of simulation period as integer
#' @param StartYear information to get the right column from read water use information
#' @param Info_GW read water use information from groundwater
#' @param Info_SW read water use information from surface water
#' @param Info_TF read water use information for transport to cities
#' @export
WaterUseCalcDaily <- function(waterUseType, dailyUse, year, month, StartYear, Info_GW, Info_SW, Info_TF) {
    invisible(.Call(`_WaterGAPLite_WaterUseCalcDaily`, waterUseType, dailyUse, year, month, StartYear, Info_GW, Info_SW, Info_TF))
}

#' @title Calculating waterbalance of basin
#' @description {
#' daily routine for each cell
#' this routine is already validated against WG3 simulation for a small basin in South America
#' especially the snow routine and immediate RunOff generation are NOT validated therefore 
#' have to check the simulation results also for other basins to assure a good match with WG3
#' e.g. for european basins with snow processes and sealed areas! (Bayern?) }
#' @param timestring Datevector with dates of simulation period
#' @return List Vwith daily water balance for whole simulaiton period as output
#' @export
createWaterBalance <- function(timestring) {
    .Call(`_WaterGAPLite_createWaterBalance`, timestring)
}

#' @title Calculate longwave radiation
#' @description estimation of longwave radiation when it is not given as measured variable
#' @param n index of specific cell
#' @param DOY day of the year (between 1 and 365)
#' @param dailyTempC Temperature of Day in Degree
#' @param dailyShortWave shortwave radiation as double in W/m²
#' @return net_long_wave_rad net longwave radiation in W/m²
#' @export
dailyEstimateLongwave <- function(n, DOY, dailyTempC, dailyShortWave) {
    .Call(`_WaterGAPLite_dailyEstimateLongwave`, n, DOY, dailyTempC, dailyShortWave)
}

#' @title Calculate shortwave radiation (after Kaspar 2004)
#' @description rcpp function to estimate Shortwave radiation when not given as measured input
#' @param dates_of_simulation Datevector of Simulation period
#' @param temperature Temperatur as NumericMatrix in degree
#' @param sunshine_duration Sunshine duration duration as NumericMatrix  in hours
#' @param row_information_GR information of row for cells
#' @param corrected_row_for_continent information of correction of rows for continental grid
#' @return shortwave_downward_radiation Matrix with estimated shortwave radiation in W/m²
#' @export
dailyEstimateShortwave <- function(dates_of_simulation, temperature, sunshine_duration, row_information_GR, corrected_row_for_continent) {
    .Call(`_WaterGAPLite_dailyEstimateShortwave`, dates_of_simulation, temperature, sunshine_duration, row_information_GR, corrected_row_for_continent)
}

#' @title snow storage interpolation
#' @description snow storage is calculated in sub-grid scale (1min) and aggregated to 5min after each day/iteration
#' @param day day of simulation period as integer
#' @param daily_prec_to_soil throughfall from canopy
#' @param G_snow snow storage at 5min scale
#' @param G_snowWaterEquivalent amount of water in snow storage at sub-grid scale
#' @param dailySnowMelt snow melt on 5min cell
#' @param dailySnowEvapo sublimation of snow on 5min cell
#' @param thresh_elev helper - information of reference height,when there is unlimited snow accummulation (> 1000mm)
#' @param dailyEffPrec effective precipitation to soil (throughfall + snow melt - fallen snow)
#' @param dailySoilPET energy for PET which is left for soil
#' @export
dailySnow <- function(day, daily_prec_to_soil, G_snow, G_snowWaterEquivalent, dailySnowMelt, dailySnowEvapo, thresh_elev, dailyEffPrec, dailySoilPET) {
    invisible(.Call(`_WaterGAPLite_dailySnow`, day, daily_prec_to_soil, G_snow, G_snowWaterEquivalent, dailySnowMelt, dailySnowEvapo, thresh_elev, dailyEffPrec, dailySoilPET))
}

#' @title soil storage implementation
#' @description core of the modle where run-off generation processes are takes part and calibration parameter gamma is implemented
#' @param dailyEffPrec effective precipitation to soil (throughfall + snow melt - fallen snow)
#' @param immediate_runoff immediate run-off that was build over sealed area and does not go into soil storage
#' @param dailySoilPET energy which is left for evapotranspration from soil
#' @param dailyCanopyEvapo evaporation amount of interception (needed to ensure that PET is not > PETdaily,max)
#' @param dailySnowEvapo sublimation amount (needed to ensure that PET is not > PETdaily,max)
#' @param G_soilWaterContent water content of soil storage (<= Smax!)
#' @param dailyAET evapotranspiration from soil storage
#' @param daily_runoff created run-off in soil storage (is later on split into fast and slow component)
#' @param soil_water_overflow overflow of soil storage which contributes directly to the fast run-off component later
#' @export
dailySoil <- function(dailyEffPrec, immediate_runoff, dailySoilPET, dailyCanopyEvapo, dailySnowEvapo, G_soilWaterContent, dailyAET, daily_runoff, soil_water_overflow) {
    invisible(.Call(`_WaterGAPLite_dailySoil`, dailyEffPrec, immediate_runoff, dailySoilPET, dailyCanopyEvapo, dailySnowEvapo, G_soilWaterContent, dailyAET, daily_runoff, soil_water_overflow))
}

#' @title Declaration of Settings from R Module
#' @description translates R Settings to global rcpp Settings
#' @param Settings Settings defined as IntegerVector
#' @export
defSettings <- function(Settings) {
    invisible(.Call(`_WaterGAPLite_defSettings`, Settings))
}

#' @title getLAIdaily
#' @description Definition of interception storage size
#' @param LAI_min minimal interception storage in mm from LAI_info
#' @param LAI_max maximal interception storage in mm from LAI_info
#' @param initDays needed days to start growing season in d from LAI_info
#' @param Temp Temperature in °C (Matrix)
#' @param Prec Precipitation in mm (Matrix)
#' @param aridType arid or humid tyoe definition for cells, obtained from G_ARID_HUMID.UNF
#' @param GLCT Landcover information
#' @return Matrix with interception storage in mm (rows=days, cols=cells)
#' @export
getLAIdaily <- function(LAI_min, LAI_max, initDays, Temp, Prec, aridType, GLCT) {
    .Call(`_WaterGAPLite_getLAIdaily`, LAI_min, LAI_max, initDays, Temp, Prec, aridType, GLCT)
}

#' @title initModel
#' @description Sets passed List as global model input
#' @param ListConst that is defined in R
#' @export
initModel <- function(ListConst) {
    invisible(.Call(`_WaterGAPLite_initModel`, ListConst))
}

#' @title routing
#' @description this function includes als routing modules
#' @param SimPeriod Datevector of Simulationperiod
#' @param surfaceRunoff run-off from surface contributing to river network
#' @param GroundwaterRunoff run-off from groundwater contributing to river network
#' @param PETw Potential Evapotranspiration as NumericMatrix in mm/d (to calculate water balance of waterbodies)
#' @param Prec Precipitation as NumericMatrix in mm/d
#' @export
routing <- function(SimPeriod, surfaceRunoff, GroundwaterRunoff, PETw, Prec) {
    .Call(`_WaterGAPLite_routing`, SimPeriod, surfaceRunoff, GroundwaterRunoff, PETw, Prec)
}

#' @title CheckResType
#' @description function to simulate reservoirs as global lakes, when res_type is zero, so unknown
#' @export
CheckResType <- function() {
    invisible(.Call(`_WaterGAPLite_CheckResType`))
}

#' @title setLakeWetlandToMaximum
#' @description function that sets storage of all surface water bodies to max; is implemented in original model version (actually because of this, warm-up-period should be quite long > 2a)
#' @param S_locLakeStorage local lake storage
#' @param S_locWetlandStorage local wetland storage
#' @param S_gloLakeStorage global lake storage
#' @param S_ResStorage reservoir storage
#' @param S_gloWetlandStorage global wetland storage
#' @export
setLakeWetlandToMaximum <- function(S_locLakeStorage, S_locWetlandStorage, S_gloLakeStorage, S_ResStorage, S_gloWetlandStorage) {
    invisible(.Call(`_WaterGAPLite_setLakeWetlandToMaximum`, S_locLakeStorage, S_locWetlandStorage, S_gloLakeStorage, S_ResStorage, S_gloWetlandStorage))
}

#' @title routingGlobalLakes
#' @description function that defines roouting through global lakes
#' @param cell cell that is simulated
#' @param PrecWater Pecipitation above cell [mm]
#' @param PETWater Potential Evaporation form water [mm]
#' @param inflow routed inflow from network to global lake [mm*km²]
#' @param gloLake_overflow overflow from global lake: overflow = (S_gloLakeStorage[cell] - maxStorage);
#' @param gloLake_outflow outflow from global lake: outflow = totalInflow + (storagePrevRouting - S_gloLakeStorage[cell])*G_LAKAREA[cell]; [mm*km²]
#' @param S_gloLakeStorage global lake storage [mm*km²]
#' @param gloLake_evapo evaporation from global lake: evaporation = (PETWater * gloLakeEvapoReductionFactor); [mm*km²]
#' @param gloLake_inflow inflow to global lake: inflow + PrecWater * G_LAKAREA[cell] [mm*km²]
#' @return total outflow form global lake: outflow + overflow [mm*km²]
#' @export
routingGlobalLakes <- function(cell, PrecWater, PETWater, inflow, gloLake_overflow, gloLake_outflow, S_gloLakeStorage, gloLake_evapo, gloLake_inflow) {
    .Call(`_WaterGAPLite_routingGlobalLakes`, cell, PrecWater, PETWater, inflow, gloLake_overflow, gloLake_outflow, S_gloLakeStorage, gloLake_evapo, gloLake_inflow)
}

#' @title routingGlobalWetlands
#' @description function that defines roouting through global wetlands
#' @param cell cell that is simulated
#' @param PrecWater Pecipitation above cell [mm]
#' @param PETWater Potential Evaporation form water [mm]
#' @param inflow routed inflow from network to global wetland [mm*km²]
#' @param gloWetland_overflow overflow from global wetland: overflow = (S_gloWetlandStorage[cell] - maxStorage) [mm*km²]
#' @param gloWetland_outflow outflow form global wetland: outflow = totalInflow + storagePrevRouting - S_gloWetlandStorage[cell] [mm*km²]
#' @param S_gloWetlandStorage global wetland storage [mm*km²]
#' @param gloWetland_evapo from global wetland: evaporation = PETWater * gloWetlEvapoReductionFactor * GAREA[cell] * (G_GLOWET[cell]/100.)[mm*km²]
#' @param gloWetland_inflow inflow to global wetland: inflow + (PrecWater * GAREA[cell] * G_GLOWET[cell]/100) [mm*km²]
#' @return total outflow form global wetland: outflow + overflow [mm*km²]
#' @export
routingGlobalWetlands <- function(cell, PrecWater, PETWater, inflow, gloWetland_overflow, gloWetland_outflow, S_gloWetlandStorage, gloWetland_evapo, gloWetland_inflow) {
    .Call(`_WaterGAPLite_routingGlobalWetlands`, cell, PrecWater, PETWater, inflow, gloWetland_overflow, gloWetland_outflow, S_gloWetlandStorage, gloWetland_evapo, gloWetland_inflow)
}

#' @title routingGlobalWetlands
#' @description function that defines routing through local waterbodies
#' @param Type 0 (local lake) or 1 (local wetland)
#' @param cell cell that is simulated
#' @param PrecWater Pecipitation above cell [mm]
#' @param PETWater Potential Evaporation form water [mm]
#' @param TempWater Mean Temperature above cell [mm]
#' @param accum_days accumulated days below -10 degree[mm]
#' @param Inflow inflow to local wb from cell=(GroundwaterRunoff(day, cell) + surfaceRunoff(day, cell))* GAREA[cell] * landfrac[cell] or (for the case of local wetlands) outflow form local lake in the case of local wetland and local lake are present [mm*km²]
#' @param S_locLakeStorage local lake storage [mmm*km²]
#' @param locLake_overflow overflow of local lake (locStorage[cell] - maxStorage) [mm*km²]
#' @param locLake_outflow outflow of local lake (only via routing, overflow is extra) [mm*km²]
#' @param locLake_evapo evaporation from local lake PETWater * locEvapoReductionFactor * (GAREA[cell] * locPerc[cell] / 100.) [mm*km²]
#' @param locLake_inflow total inflow to local lake Inflow + PrecWater * (GAREA[cell] * locPerc[cell] / 100.); // mm km²
#' @param S_locWetlandStorage local wetland storage [mm*km²]
#' @param locWetland_overflow overflow of local wetland (locStorage[cell] - maxStorage) [mm*km²]
#' @param locWetland_outflow outflow of local wetland (only via routing, overflow is extra) [mm*km²]
#' @param locWetland_evapo evaporation from local wetland PETWater * locEvapoReductionFactor * (GAREA[cell] * locPerc[cell] / 100.) [mm*km²]
#' @param locWetland_inflow inflow to local wetland Inflow + PrecWater * (GAREA[cell] * locPerc[cell] / 100.); // mm km²
#' @return routed outflow from local waterbody [mm*km²]
#' @export
routingLocalWaterBodies <- function(Type, cell, PrecWater, PETWater, TempWater, accum_days, snow_storage_wetland, Inflow, S_locLakeStorage, locLake_overflow, locLake_outflow, locLake_evapo, locLake_inflow, S_locWetlandStorage, locWetland_overflow, locWetland_outflow, locWetland_evapo, locWetland_inflow) {
    .Call(`_WaterGAPLite_routingLocalWaterBodies`, Type, cell, PrecWater, PETWater, TempWater, accum_days, snow_storage_wetland, Inflow, S_locLakeStorage, locLake_overflow, locLake_outflow, locLake_evapo, locLake_inflow, S_locWetlandStorage, locWetland_overflow, locWetland_outflow, locWetland_evapo, locWetland_inflow)
}

#' @title routingResHanasaki
#' @description function that defines routing through reservoir (after Hanasaki)
#' @param day of simulation period (0 = 1st day of simulation period)
#' @param cell cell that is simulated
#' @param SimDate Date of day which is simulated
#' @param PETWater Potential Evaporation from water [mm]
#' @param PrecWater Pecipitation above cell [mm]
#' @param inflow inflow to reservoir from network [mm*km²]
#' @param Res_outflow  outflow from reservoir (excluding overflow) [mm*km²]
#' @param Res_overflow overflow of reservoir [mm*km²]
#' @param S_ResStorage storage of reservoir [mm*km²]
#' @param Res_evapo evaporation from reservoir: evaporation = (PETWater * gloResEvapoReductionFactor)* G_RESAREA[cell] [mm*km²]
#' @param Res_inflow inflow to reservoir: inflow + ( PrecWater * G_RESAREA[cell]);//[mm km²]
#' @param dailyUse information of water that needs to be abstracted from surface water (second row of NumericMatrix)
#' @param MeanDemand output of WaterUseCalcMeanDemandDaily(year, GapYearType)
#' @return total outflow form reservoir: outflow + overflow [mm*km²]
#' @export
routingResHanasaki <- function(day, cell, SimDate, PETWater, PrecWater, inflow, Res_outflow, Res_overflow, S_ResStorage, Res_evapo, Res_inflow, dailyUse, MeanDemand) {
    .Call(`_WaterGAPLite_routingResHanasaki`, day, cell, SimDate, PETWater, PrecWater, inflow, Res_outflow, Res_overflow, S_ResStorage, Res_evapo, Res_inflow, dailyUse, MeanDemand)
}

#' @title routingRiver
#' @description function that defines routing through river - note: uses original model code with bug in ELS equation
#' @param cell cell that is simulated
#' @param riverVelocity river velocity in km/d
#' @param RiverInflow inflow to river network [mm*km²/d]
#' @param G_riverOutflow transportedVolume in [mm*km²/d]
#' @param S_river river storage [mm*km²]
#' @return transportedVolume in [mm*km²/d]
#' @export
routingRiver <- function(cell, riverVelocity, RiverInflow, G_riverOutflow, S_river) {
    .Call(`_WaterGAPLite_routingRiver`, cell, riverVelocity, RiverInflow, G_riverOutflow, S_river)
}

#' @title getRiverVelocity
#' @description function that defines river velocity for routing (variable or constant)
#' @param Type 0 (constant) or 1 (variable)
#' @param cell cell that is simulated
#' @param inflow inflow to river in mm*km²/day
#' @return riverVelocity in km/day
#' @export
getRiverVelocity <- function(Type, cell, inflow) {
    .Call(`_WaterGAPLite_getRiverVelocity`, Type, cell, inflow)
}

#' @title runModel
#' @description run whole model including model initializing, warm-up period, water balance and routing and returns list with states and fluxes 
#' @param SimPeriod Period to simulate (usually defines as model[["SimPeriod"]] where model is object returned from basin.prepareRun())
#' @param ListConst list with all required information regarding basin and input (usually, object returned by basin.prepareRun())
#' @param Settings vector of length 8 that is used to define settings:
#'  \itemize{
#'   \item 1st entry: water use               -> 0 (off), 1 (on), 2 (on, including water transport to cities)
#'   \item 2nd entry: water use allocation    -> 0 (temporal & spatial distr.), 1 (spatial distr.), 2 (temporal distr.)
#'   \item 3rd entry: flow velocity           -> 0 (constant), 1 (variable)
#'   \item 4th entry: gap year                -> 0 (including 29.02), 1 (without 29.02)
#'   \item 5th entry: reservoir algorithm     -> 0 (Hanasaki), 1 (global lake)
#'   \item 6th entry: splitting factor        -> 0 (original version), 1 (set as parameter) - only used for development purposes
#'   \item 7th entry: long wave radiation     -> 0 (reading), 1 (calculating)
#'   \item 8th entry: warm up period          -> 0 (no system values), 1 (system values are read), 2 (system values are written), 3 (system values are read and written) 
#'   \item 9th entry: snow in wetland           -> 0 (off), 1 (on) }
#' @param nYears number of years defined as warm-up (first year is then simulated n times, before starting with the actual simulation)
#' @export
runModel <- function(SimPeriod, ListConst, Settings, nYears) {
    .Call(`_WaterGAPLite_runModel`, SimPeriod, ListConst, Settings, nYears)
}

#' @title tools_DefDrainageCells
#' @description rcpp tool to define Drainage Cells 
#' @param Outlet of basin as GCRC number in continental grid
#' @param GCRC as vector for continent
#' @param OutflowMatrix as vector for continent 
#' @return IntegerVector with GCRC-IDs that are part of basin
#' @export
tools_DefDrainageCells <- function(Outlet, GCRC, OutflowMatrix) {
    .Call(`_WaterGAPLite_tools_DefDrainageCells`, Outlet, GCRC, OutflowMatrix)
}

#' @title tools_interpolate
#' @description rcpp function for interpolation of a vector (alternative could be using r function and apply)
#' @param VectorIn vector as base for interpolation
#' @param Table_x Table_x of values
#' @param Table_y Table_y of values
#' @return NumericVector with interpolated output
#' @export
tools_interpolate <- function(VectorIn, Table_x, Table_y) {
    .Call(`_WaterGAPLite_tools_interpolate`, VectorIn, Table_x, Table_y)
}

